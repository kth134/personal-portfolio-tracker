import { format, parseISO } from 'date-fns';\n\nexport function calculateIRR(cashflows: number[], dates: Date[], tolerance: number = 1e-7, maxIterations: number = 200, guess: number = 0.10): number {\n  const calcNPV = (rate: number): number => {\n    let npv = 0;\n    for (let i = 0; i < cashflows.length; i++) {\n      const years = (dates[i].getTime() - dates[0].getTime()) / (365.25 * 24 * 60 * 60 * 1000);\n      npv += cashflows[i] * Math.pow(1 + rate, -years);\n    }\n    return npv;\n  };\n\n  const calcNPVDerivative = (rate: number): number => {\n    let deriv = 0;\n    for (let i = 0; i < cashflows.length; i++) {\n      const years = (dates[i].getTime() - dates[0].getTime()) / (365.25 * 24 * 60 * 60 * 1000);\n      deriv += -years * cashflows[i] * Math.pow(1 + rate, -(years + 1));\n    }\n    return deriv;\n  };\n\n  let irr = guess;\n  for (let i = 0; i < maxIterations; i++) {\n    const npv = calcNPV(irr);\n    if (Math.abs(npv) < tolerance) return irr;\n\n    const deriv = calcNPVDerivative(irr);\n    if (Math.abs(deriv) < 1e-10) break;\n\n    const delta = npv / deriv;\n    irr -= delta;\n    if (Math.abs(delta) < tolerance) return irr;\n  }\n  return NaN;\n};\n\nexport function calculateTWR(values: number[], dates: Date[]): number {\n  if (values.length < 2) return 0;\n  let twr = 1;\n  for (let i = 1; i < values.length; i++) {\n    twr *= values[i] / values[i - 1];\n  }\n  return twr - 1;\n};\n\nexport function calculateAnnualizedReturn(totalReturn: number, days: number): number {\n  const years = days / 365.25;\n  return years > 0 ? Math.pow(1 + totalReturn, 1 / years) - 1 : totalReturn;\n};\n\nexport function transactionFlowForIRR(tx: any): number {\n  const amount = Number(tx.amount || 0);\n  const fees = Number(tx.fees || 0);\n  const type = tx.type;\n\n  let sign = 0;\n  if (type === 'Deposit') sign = -1;\n  else if (type === 'Withdrawal') sign = 1;\n  return sign * amount - Math.abs(fees);\n};\n\nexport function netCashFlowsByDate(flows: number[], dates: Date[]) {\n  const dailyNet: Record<string, number> = {};\n  for (let i = 0; i < flows.length; i++) {\n    const dateStr = format(dates[i], 'yyyy-MM-dd');\n    dailyNet[dateStr] = (dailyNet[dateStr] || 0) + flows[i];\n  }\n\n  const sortedDates = Object.keys(dailyNet).sort();\n  const netDates: Date[] = [];\n  const netFlows: number[] = [];\n  sortedDates.forEach(dateStr => {\n    netDates.push(parseISO(dateStr));\n    netFlows.push(dailyNet[dateStr]);\n  });\n\n  return { netFlows, netDates };\n};\n\nexport function logCashFlows(label: string, flows: number[], dates: Date[]) {\n  console.group(label);\n  for (let i = 0; i < flows.length; i++) {\n    console.log(`${format(dates[i], 'yyyy-MM-dd')}: ${flows[i].toFixed(4)}`);\n  }\n  console.groupEnd();\n};\n\nexport function normalizeTransactionToFlow(tx: any): number {\n  return transactionFlowForIRR(tx);\n};\n\nexport const lenses = ['total', 'account', 'sub_portfolio', 'asset_type', 'asset_subtype', 'geography', 'size_tag', 'factor_tag'] as const;\n\nexport interface Transaction {\n  id: string;\n  user_id: string;\n  account_id: string;\n  asset_id?: string;\n  type: string;\n  date: string;\n  amount: number;\n  fees: number;\n  quantity?: number;\n  price_per_unit?: number;\n  realized_gain?: number;\n  account?: { id: string; name: string; type: string };\n  asset?: { id: string; ticker: string; name: string };\n};\n\nexport const fetchAllUserTransactionsServer = async (supabase: any, userId: string): Promise<Transaction[]> => {\n  const { data: transactions, error } = await supabase\n    .from('transactions')\n    .select(`\n      *,\n      accounts (id, name, type),\n      assets (id, ticker, name)\n    `)\n    .eq('user_id', userId)\n    .order('date', { ascending: false });\n  if (error) {\n    console.error('Error fetching transactions:', error);\n    throw error;\n  }\n  return transactions ?? [];\n};\n\nexport const calculateCashBalances = (transactions: Transaction[]): { balances: Map<string, number>; totalCash: number } => {\n  const balances = new Map<string, number>();\n  const byAccount: Record<string, Transaction[]> = {};\n  transactions.forEach((tx) => {\n    const accId = tx.account_id ?? tx.account?.id;\n    if (accId) {\n      if (!byAccount[accId]) byAccount[accId] = [];\n      byAccount[accId].push(tx);\n    }\n  });\n  Object.entries(byAccount).forEach(([accId, txs]) => {\n    txs.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());\n    let bal = 0;\n    txs.forEach((tx) => {\n      const amt = Number(tx.amount || 0);\n      const fee = Math.abs(Number(tx.fees || 0));\n      const type = tx.type;\n      switch (type) {\n        case 'Deposit':\n          bal += amt;\n          break;\n        case 'Withdrawal':\n          bal -= amt;\n          break;\n        case 'Dividend':\n        case 'Interest':\n          bal += amt;\n          break;\n        case 'Buy':\n          bal -= amt + fee;\n          break;\n        case 'Sell':\n          bal += amt - fee;\n          break;\n      }\n    });\n    balances[accId] = bal;\n  });\n  const totalCash = Array.from(balances.values()).reduce((sum, b) => sum + b, 0);\n  return { balances, totalCash };\n};\n\nexport const refreshAssetPrices = async () => {\n  // Server action: trigger price fetch\n  // await fetch('/api/fetch-prices', { method: 'POST' });\n};\n\nexport const fetchAllUserTransactions = async () => {\n  // Client-side: use useQuery\n  return [];\n};\n\nexport const formatCashFlowsDebug = (flows: number[], dates: Date[]) => {\n  if (!flows || !dates) return '';\n  return flows.map((f, i) => `${dates[i].toLocaleDateString()}: $${f.toFixed(2)}`).join('\\n');\n};\n\nexport const getPerformanceData = async () => []; // Use API endpoints