import { format, parseISO } from &#x27;date-fns&#x27;;\n\n export function calculateIRR(cashflows: number[], dates: Date[], tolerance: number = 1e-7, maxIterations: number = 200, guess: number = 0.10): number {\n  const calcNPV = (rate: number): number =&gt; {\n    let npv = 0;\n    for (let i = 0; i &lt; cashflows.length; i++) {\n      const years = (dates[i].getTime() - dates[0].getTime()) / (365.25 * 24 * 60 * 60 * 1000);\n      npv += cashflows[i] * Math.pow(1 + rate, -years);\n    }\n    return npv;\n  };\n\n  const calcNPVDerivative = (rate: number): number =&gt; {\n    let deriv = 0;\n    for (let i = 0; i &lt; cashflows.length; i++) {\n      const years = (dates[i].getTime() - dates[0].getTime()) / (365.25 * 24 * 60 * 60 * 1000);\n      deriv += -years * cashflows[i] * Math.pow(1 + rate, -(years + 1));\n    }\n    return deriv;\n  };\n\n  let irr = guess;\n  for (let i = 0; i &lt; maxIterations; i++) {\n    const npv = calcNPV(irr);\n    if (Math.abs(npv) &lt; tolerance) return irr;\n\n    const deriv = calcNPVDerivative(irr);\n    if (Math.abs(deriv) &lt; 1e-10) break;\n\n    const delta = npv / deriv;\n    irr -= delta;\n    if (Math.abs(delta) &lt; tolerance) return irr;\n  }\n  return NaN;\n};\n\nexport function calculateTWR(values: number[], dates: Date[]): number {\n  if (values.length &lt; 2) return 0;\n  let twr = 1;\n  for (let i = 1; i &lt; values.length; i++) {\n    twr *= values[i] / values[i - 1];\n  }\n  return twr - 1;\n};\n\nexport function calculateAnnualizedReturn(totalReturn: number, days: number): number {\n  const years = days / 365.25;\n  return years &gt; 0 ? Math.pow(1 + totalReturn, 1 / years) - 1 : totalReturn;\n};\n\nexport function transactionFlowForIRR(tx: any): number {\n  const amount = Number(tx.amount || 0);\n  const fees = Number(tx.fees || 0);\n  const type = tx.type;\n\n  let sign = 0;\n  if (type === &#x27;Deposit&#x27;) sign = -1;\n  else if (type === &#x27;Withdrawal&#x27;) sign = 1;\n  return sign * amount - Math.abs(fees);\n};\n\nexport function netCashFlowsByDate(flows: number[], dates: Date[]) {\n  const dailyNet: Record&lt;string, number&gt; = {};\n  for (let i = 0; i &lt; flows.length; i++) {\n    const dateStr = format(dates[i], &#x27;yyyy-MM-dd&#x27;);\n    dailyNet[dateStr] = (dailyNet[dateStr] || 0) + flows[i];\n  }\n\n  const sortedDates = Object.keys(dailyNet).sort();\n  const netDates: Date[] = [];\n  const netFlows: number[] = [];\n  sortedDates.forEach(dateStr =&gt; {\n    netDates.push(parseISO(dateStr));\n    netFlows.push(dailyNet[dateStr]);\n  });\n\n  return { netFlows, netDates };\n};\n\nexport function logCashFlows(label: string, flows: number[], dates: Date[]) {\n  console.group(label);\n  for (let i = 0; i &lt; flows.length; i++) {\n    console.log(`${format(dates[i], &#x27;yyyy-MM-dd&#x27;)}: ${flows[i].toFixed(4)}`);\n  }\n  console.groupEnd();\n};\n\nexport function normalizeTransactionToFlow(tx: any): number {\n  return transactionFlowForIRR(tx);\n};\n\nexport const lenses = [&#x27;total&#x27;, &#x27;account&#x27;, &#x27;sub_portfolio&#x27;, &#x27;asset_type&#x27;, &#x27;asset_subtype&#x27;, &#x27;geography&#x27;, &#x27;size_tag&#x27;, &#x27;factor_tag&#x27;] as const;\n\nexport interface Transaction {\n  id: string;\n  user_id: string;\n  account_id: string;\n  asset_id?: string;\n  type: string;\n  date: string;\n  amount: number;\n  fees: number;\n  quantity?: number;\n  price_per_unit?: number;\n  realized_gain?: number;\n  account?: { id: string; name: string; type: string };\n  asset?: { id: string; ticker: string; name: string };\n};\n\nexport const fetchAllUserTransactionsServer = async (supabase: any, userId: string): Promise&lt;Transaction[]&gt; =&gt; {\n  const { data: transactions, error } = await supabase\n    .from(&#x27;transactions&#x27;)\n    .select(`\n      *,\n      accounts (id, name, type),\n      assets (id, ticker, name)\n    `)\n    .eq(&#x27;user_id&#x27;, userId)\n    .order(&#x27;date&#x27;, { ascending: false });\n  if (error) {\n    console.error(&#x27;Error fetching transactions:&#x27;, error);\n    throw error;\n  }\n  return transactions ?? [];\n};\n\nexport const calculateCashBalances = (transactions: Transaction[]): { balances: Map&lt;string, number&gt;; totalCash: number } =&gt; {\n  const balances = new Map&lt;string, number&gt;();\n  const byAccount: Record&lt;string, Transaction[]&gt; = {};\n  transactions.forEach((tx) =&gt; {\n    const accId = tx.account_id ?? tx.account?.id;\n    if (accId) {\n      if (!byAccount[accId]) byAccount[accId] = [];\n      byAccount[accId].push(tx);\n    }\n  });\n  Object.entries(byAccount).forEach(([accId, txs]) =&gt; {\n    txs.sort((a, b) =&gt; new Date(a.date).getTime() - new Date(b.date).getTime());\n    let bal = 0;\n    txs.forEach((tx) =&gt; {\n      const amt = Number(tx.amount || 0);\n      const fee = Math.abs(Number(tx.fees || 0));\n      const type = tx.type;\n      switch (type) {\n        case &#x27;Deposit&#x27;:\n          bal += amt;\n          break;\n        case &#x27;Withdrawal&#x27;:\n          bal -= amt;\n          break;\n        case &#x27;Dividend&#x27;:\n        case &#x27;Interest&#x27;:\n          bal += amt;\n          break;\n        case &#x27;Buy&#x27;:\n          bal -= amt + fee;\n          break;\n        case &#x27;Sell&#x27;:\n          bal += amt - fee;\n          break;\n      }\n    });\n    balances[accId] = bal;\n  });\n  const totalCash = Array.from(balances.values()).reduce((sum, b) =&gt; sum + b, 0);\n  return { balances, totalCash };\n};\n\nexport const refreshAssetPrices = async () =&gt; {\n  // Server action: trigger price fetch\n  // await fetch(&#x27;/api/fetch-prices&#x27;, { method: &#x27;POST&#x27; });\n};\n\nexport const fetchAllUserTransactions = async () =&gt; {\n  // Client-side: use useQuery\n  return [];\n};\n\nexport const formatCashFlowsDebug = (flows: number[], dates: Date[]) =&gt; {\n  if (!flows || !dates) return &#x27;&#x27;;\n  return flows.map((f, i) =&gt; `${dates[i].toLocaleDateString()}: $${f.toFixed(2)}`).join(&#x27;\\n&#x27;);\n};\n\nexport const getPerformanceData = async () =&gt; []; // Use API endpoints